# PostgreSQL configuration optimized for local development in Docker Compose
# ==========================================================================

################################## CONNECTION #####################################
listen_addresses = '*'                  # Allow connections from all interfaces
port = 5432                             # Standard PostgreSQL port
max_connections = 100                   # Reasonable default for development
superuser_reserved_connections = 3      # Reserve connections for admin use
tcp_keepalives_idle = 60                # TCP keepalive idle time (seconds)
tcp_keepalives_interval = 10            # TCP keepalive interval (seconds)
tcp_keepalives_count = 10               # TCP keepalive retry count
tcp_user_timeout = 0                    # TCP user timeout (uses system default)
unix_socket_directories = '/var/run/postgresql'  # Unix socket location
client_connection_check_interval = 100  # Check client connection every 100ms

################################## MEMORY USAGE ##################################
shared_buffers = 256MB                  # ~25% of available RAM for development
work_mem = 32MB                         # Per-operation memory for sorts/joins
maintenance_work_mem = 64MB             # Memory for maintenance operations
effective_cache_size = 1GB              # Estimate of available system cache
temp_buffers = 8MB                      # Per-session memory for temp tables
dynamic_shared_memory_type = posix      # Memory implementation type
hash_mem_multiplier = 2.0               # Memory multiplier for hash operations
autovacuum_work_mem = 128MB             # Memory for autovacuum operations
logical_decoding_work_mem = 64MB        # Memory for logical decoding

################################## DISK USAGE ###################################
temp_file_limit = 1GB                   # Limit per-process temp file usage
max_files_per_process = 1000            # Max open files per backend

################################## WAL CONFIGURATION ############################
wal_level = logical                     # Enable logical decoding for dev tools
max_wal_size = 1GB                      # Max WAL size before checkpoint
min_wal_size = 80MB                     # Min WAL size to keep
checkpoint_timeout = 5min               # Time between checkpoints
checkpoint_completion_target = 0.9      # Target duration as fraction of interval
checkpoint_warning = 30s                # Warning if checkpoints occur too frequently
wal_buffers = 16MB                      # WAL write buffer size
synchronous_commit = off                # Disable sync commits for better perf
full_page_writes = on                   # Critical for crash safety
wal_compression = on                    # Compress WAL data
wal_init_zero = on                      # Zero WAL files before use
wal_recycle = on                        # Reuse WAL files
# Disable archive mode for local development
archive_mode = off                      # Don't archive WAL files
# archive_command = ''                  # Command to archive WAL file

################################## QUERY TUNING #################################
# Enable all plan types for testing/optimization
enable_bitmapscan = on
enable_hashagg = on
enable_hashjoin = on
enable_indexscan = on
enable_indexonlyscan = on
enable_material = on
enable_mergejoin = on
enable_nestloop = on
enable_seqscan = on
enable_sort = on
enable_tidscan = on
enable_partitionwise_join = on         # Enable partition-wise join (for testing)
enable_partitionwise_aggregate = on     # Enable partition-wise agg (for testing)
# Cost model parameters
random_page_cost = 1.1                  # Lowered for SSDs (4.0 is HDD default)
cpu_tuple_cost = 0.01                   # Default CPU tuple cost 
cpu_index_tuple_cost = 0.005            # Default CPU index tuple cost
cpu_operator_cost = 0.0025              # Default CPU operator cost
# Optimizer settings
default_statistics_target = 100         # Stats target for columns
constraint_exclusion = partition        # Use constraints for partition pruning
cursor_tuple_fraction = 0.1             # Fraction of cursor expected to be fetched
from_collapse_limit = 8                 # FROM list size for subquery collapse
join_collapse_limit = 8                 # FROM list size for join collapse
# JIT compilation for complex queries
jit = on                                # Enable JIT compilation
jit_above_cost = 100000                 # Use JIT if query cost exceeds this
jit_inline_above_cost = 500000          # Use JIT inlining if cost exceeds this
jit_optimize_above_cost = 500000        # Use JIT optimization if cost exceeds this

################################## PARALLEL QUERY ###############################
max_parallel_workers_per_gather = 4     # Max parallel workers per gather node
max_parallel_maintenance_workers = 2    # Max parallel workers for maintenance
max_parallel_workers = 8                # Max total parallel workers
parallel_leader_participation = on      # Leader also executes part of the plan

################################## LOGGING AND MONITORING #######################
log_destination = 'stderr'              # Log to stderr (works with Docker)
logging_collector = off                 # Don't collect logs to file
log_min_messages = warning              # Increased from notice to warning to reduce logs
log_min_error_statement = error         # Min level for logging statements causing errors
client_min_messages = notice            # Min message level sent to client
log_min_duration_statement = 1000       # Increased from 100ms to 1s to log only slow queries
log_checkpoints = off                   # Disabled checkpoint logging
log_connections = off                   # Disabled connection logging
log_disconnections = off                # Disabled disconnection logging
log_duration = off                      # Don't log duration of all statements
log_error_verbosity = default           # Default verbosity for error logs
log_lock_waits = on                     # Log long lock waits
log_statement = 'mod'                   # Changed from 'ddl' to 'mod' to log only data-modifying statements
log_temp_files = 1MB                    # Log only large temp files (>1MB)
log_line_prefix = '%m [%p] %q %u@%d '   # Prefix for log lines
# Performance monitoring
track_activities = on                   # Track executing commands
track_counts = on                       # Collect database activity statistics
track_io_timing = on                    # Track timing of I/O calls
track_functions = pl                    # Track only PL function calls, not SQL
track_activity_query_size = 4096        # Size for query strings in pg_stat_activity
compute_query_id = on                   # Compute query identifiers

################################## AUTOVACUUM ##################################
autovacuum = on                         # Enable autovacuum
autovacuum_max_workers = 3              # Max number of autovacuum workers
autovacuum_naptime = 20s                # Time between autovacuum runs (shorter for dev)
autovacuum_vacuum_threshold = 50        # Threshold for vacuum
autovacuum_analyze_threshold = 50       # Threshold for analyze
autovacuum_vacuum_scale_factor = 0.1    # Fraction of table before vacuum
autovacuum_analyze_scale_factor = 0.05  # Fraction of table before analyze
autovacuum_vacuum_cost_delay = 2ms      # Cost-based vacuum delay
autovacuum_vacuum_cost_limit = 200      # Cost limit for autovacuum
# Log autovacuum activity
log_autovacuum_min_duration = 1000      # Log only autovacuum operations taking more than 1s

################################## STATISTICS ##################################
# Query Statistics
track_counts = on                       # Collect statistics on database activity
track_io_timing = on                    # Track timing statistics for database I/O
track_wal_io_timing = on                # Track timing statistics for WAL I/O
stats_fetch_consistency = cache         # Use cached statistics when available

################################## DEVELOPER FEATURES ##########################
default_transaction_isolation = 'read committed'  # Default isolation level
default_transaction_read_only = off      # Default read-only status
statement_timeout = 0                    # Statement timeout (0=no timeout)
lock_timeout = 0                         # Lock wait timeout (0=no timeout)
idle_in_transaction_session_timeout = 0  # Session timeout (0=no timeout)

################################## CLIENT CONNECTION DEFAULTS #################
search_path = '"$user", public'          # Schema search path
dynamic_library_path = '$libdir'         # Path for loadable modules
local_preload_libraries = ''             # Libraries to preload into each backend
# Date/time settings
DateStyle = 'ISO, MDY'                   # Date format
TimeZone = 'UTC'                         # Timezone for timestamps
# Locale settings
lc_messages = 'en_US.UTF-8'              # Locale for system messages
lc_monetary = 'en_US.UTF-8'              # Locale for monetary formatting
lc_numeric = 'en_US.UTF-8'               # Locale for number formatting
lc_time = 'en_US.UTF-8'                  # Locale for time formatting

################################## SHARED LIBRARIES ###########################
# Extensions and preloaded libraries
shared_preload_libraries = 'pg_stat_statements,auto_explain'  # Libraries to preload

################################## CUSTOM SETTINGS ############################
# auto_explain configuration (for query plan analysis)
auto_explain.log_min_duration = '1000ms' # Increased from 100ms to 1000ms
auto_explain.log_analyze = true          # Include EXPLAIN ANALYZE output
auto_explain.log_buffers = true          # Include buffer usage
auto_explain.log_timing = true           # Include timing information
auto_explain.log_triggers = true         # Include trigger statistics
auto_explain.log_verbose = false         # Don't use EXPLAIN VERBOSE
auto_explain.log_format = 'text'         # Use text format (not JSON)
auto_explain.log_nested_statements = true # Include nested statements

# pg_stat_statements configuration (for query statistics)
pg_stat_statements.max = 10000           # Maximum number of statements to track
pg_stat_statements.track = all           # Track all statements
pg_stat_statements.track_utility = false # Don't track utility commands
pg_stat_statements.track_planning = true # Track planning time
pg_stat_statements.save = true           # Save stats across server shutdowns

################################## EXTENSIONS #################################
# Uncomment specific extensions you need for development
# These settings control custom extension parameters
# Vector extension settings 
# vector.dimensions = 1536                # Default dimension for vector columns
# Vector indexes are configured at table level

# PostGIS settings (if needed)
# postgis.gdal_enabled_drivers = 'ENABLE_ALL'  # Enable all GDAL drivers

# pgAudit settings (if needed)
# pgaudit.log = 'all'                    # Log all auditable events
# pgaudit.log_catalog = off              # Don't log catalog queries
# pgaudit.log_parameter = on             # Log parameter values

################################## SECURITY ##################################
# Development environment security is relaxed
password_encryption = 'scram-sha-256'    # Use modern password hashing
row_security = on                        # Enable row security
allow_system_table_mods = off            # Don't allow system table modifications

################################## Full documentation ########################


# PostgreSQL Configuration File (postgresql.conf)
# =============================================
#
# This comprehensive configuration file contains all PostgreSQL parameters
# with detailed explanations, usage recommendations, and warnings.
#
# HOW TO USE THIS FILE:
# 1. Review the settings and adjust them according to your needs
# 2. Uncomment parameters by removing the leading '#' to activate them
# 3. After making changes, reload or restart PostgreSQL as required
#
# RELOAD vs RESTART:
# - Parameters marked as "context: sighup" can be changed with a reload (pg_ctl reload)
# - Parameters marked as "context: postmaster" require a full server restart
#
# This file is organized into sections:
# - FILE LOCATIONS
# - CONNECTIONS AND AUTHENTICATION
# - RESOURCE USAGE
# - MEMORY USAGE
# - WRITE AHEAD LOG (WAL)
# - REPLICATION
# - WAL AND RECOVERY
# - QUERY TUNING
# - LOGGING AND MONITORING
# - STATISTICS
# - AUTOVACUUM
# - CLIENT CONNECTION DEFAULTS
# - LOCK MANAGEMENT
# - VERSION AND PLATFORM COMPATIBILITY
# - ERROR HANDLING
# - CUSTOMIZED OPTIONS
# - BACKGROUND WRITER

#------------------------------------------------------------------------------
# FILE LOCATIONS
#------------------------------------------------------------------------------

# PostgreSQL stores its data in several locations. This section configures
# the paths to the key files PostgreSQL needs to function.

#------------------------------------------------------------------------------
# DATA DIRECTORY
#------------------------------------------------------------------------------

# The data directory is the location where all database data, WAL files,
# and configuration files are stored. This is the most critical directory
# in PostgreSQL and should be on reliable storage with sufficient space.
#
# This parameter can only be set at server start and cannot be changed
# without restarting the server.
#
# context: postmaster
# data_directory = '/var/lib/postgresql/15/main'

#------------------------------------------------------------------------------
# CONFIGURATION FILES
#------------------------------------------------------------------------------

# The main configuration file (this file). This parameter is typically set
# via command line or environment variables.
#
# context: postmaster
# config_file = '/etc/postgresql/15/main/postgresql.conf'

# The HBA (host-based authentication) file controls client authentication
# by specifying which users can connect from which hosts using which
# authentication methods.
#
# context: postmaster
# hba_file = '/etc/postgresql/15/main/pg_hba.conf'

# The ident file is used with the "ident" authentication method to map
# operating system usernames to PostgreSQL usernames.
#
# context: postmaster
# ident_file = '/etc/postgresql/15/main/pg_ident.conf'

# If set, PostgreSQL will write its process ID to this file. This is
# useful for scripts that need to interact with the server.
#
# context: postmaster
# external_pid_file = '/var/run/postgresql/15-main.pid'


#------------------------------------------------------------------------------
# CONNECTIONS AND AUTHENTICATION
#------------------------------------------------------------------------------

# This section configures how clients connect to the server and how
# authentication is handled.

#------------------------------------------------------------------------------
# CONNECTION SETTINGS
#------------------------------------------------------------------------------

# Controls which IP addresses to listen on for incoming connections.
# Comma-separated list of addresses; defaults to 'localhost' for security.
# Use '*' to listen on all available IP interfaces, but this presents
# security risks if firewall is not properly configured.
#
# Examples:
#   listen_addresses = 'localhost'         # Only allow local connections
#   listen_addresses = 'localhost,192.168.1.10'  # Listen on specific interfaces
#   listen_addresses = '*'                 # Listen on all interfaces
#
# WARNING: Setting to '*' without proper firewall rules can expose your
# database to unauthorized access from the internet.
#
# context: postmaster
# listen_addresses = 'localhost'

# The TCP port the server listens on; 5432 is the IANA-assigned PostgreSQL port.
# If set to 0, PostgreSQL won't listen on any TCP ports.
#
# context: postmaster
# port = 5432

# Maximum number of concurrent connections to the database server.
# Each connection consumes memory, so this value should be set based on:
# 1. Available system memory
# 2. Expected number of concurrent users
# 3. Memory allocated to other PostgreSQL settings (shared_buffers, etc.)
#
# For small to medium deployments, a value of 100-200 is common.
# High-traffic applications might need 300-500 or more.
#
# context: postmaster
# max_connections = 100

# Number of connection slots reserved for superusers. This ensures that
# administrators can connect to fix problems even when all regular
# connection slots are taken.
#
# context: postmaster
# superuser_reserved_connections = 3

# Unix domain socket directory. Multiple directories can be specified,
# separated by commas. Empty string disables Unix domain socket connections.
#
# context: postmaster
# unix_socket_directories = '/var/run/postgresql'

# Unix domain socket file access permissions (in octal).
# Recommended setting is 0777 unless you have specific security requirements.
#
# context: postmaster
# unix_socket_permissions = 0777

# The Unix group that owns the socket. The default is usually the PostgreSQL
# system user's group. You can change this to control socket access at group level.
#
# context: postmaster
# unix_socket_group = ''

# The maximum time to wait for client authentication to complete.
# Increase this on slow networks or when using complex authentication methods.
#
# context: sighup
# authentication_timeout = 1min

# If off, you can't have a username that exists in both PostgreSQL and the
# operating system. If on, you can have different PostgreSQL users in each
# database with the same name as operating system users.
#
# context: sighup
# db_user_namespace = off

#------------------------------------------------------------------------------
# BONJOUR SETTINGS
#------------------------------------------------------------------------------

# Whether to advertise server availability via Bonjour.
# Useful for automatic server discovery on local networks.
#
# context: postmaster
# bonjour = off

# Sets the Bonjour service name.
# This is what the server will identify as on the Bonjour network.
# Empty string selects the computer name.
#
# context: postmaster
# bonjour_name = ''

#------------------------------------------------------------------------------
# GSSAPI AND KERBEROS DELEGATION
#------------------------------------------------------------------------------

# Controls whether GSSAPI delegation should be accepted from client.
# When enabled, allows forwarding of client credentials to other services.
# Only enable if your application needs to access other Kerberos-secured services.
#
# context: sighup
# gss_accept_delegation = off

#------------------------------------------------------------------------------
# RESERVED CONNECTIONS
#------------------------------------------------------------------------------

# Sets the number of connection slots reserved for roles with privileges of 
# pg_use_reserved_connections. This ensures that certain applications or
# monitoring tools can connect even when the server reaches max_connections.
#
# context: postmaster
# reserved_connections = 0


#------------------------------------------------------------------------------
# SECURITY AND AUTHENTICATION
#------------------------------------------------------------------------------

# SSL
# ---
# Enable SSL connections for added security. Requires SSL certificates to be
# properly set up. When enabled, clients can choose whether to use SSL.
#
# context: sighup
# ssl = off

# Locations of SSL certificate files. These need to be properly configured
# when SSL is enabled.
#
# context: sighup
# ssl_cert_file = 'server.crt'
# ssl_key_file = 'server.key'
# ssl_ca_file = ''
# ssl_crl_file = ''
# ssl_crl_dir = ''

# Controls which SSL ciphersuites are allowed. The default provides a good
# balance of security and compatibility.
#
# context: sighup
# ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'

# Whether the server should prefer its own cipher order over client's.
# Should generally be 'on' for better security.
#
# context: sighup
# ssl_prefer_server_ciphers = on

# Curve to use for ECDH. Should be a well-known, secure curve.
#
# context: sighup
# ssl_ecdh_curve = 'prime256v1'

# Minimum TLS protocol version to allow. Modern installations should use
# TLSv1.2 or higher for security.
#
# context: sighup
# ssl_min_protocol_version = 'TLSv1.2'

# Maximum TLS protocol version to use. Usually best left unset unless you
# have compatibility issues with specific clients.
#
# context: sighup
# ssl_max_protocol_version = ''

# Location of DH parameters file. Used to generate ephemeral DH keys.
#
# context: sighup
# ssl_dh_params_file = ''

# Kerberos and GSSAPI
# ------------------
# Location of the Kerberos server key file when using Kerberos authentication.
#
# context: sighup
# krb_server_keyfile = 'FILE:/etc/postgresql-common/krb5.keytab'

# Whether Kerberos and GSSAPI user names should be treated as case-insensitive.
# Set to on if your Kerberos implementation uses case-insensitive names.
#
# context: sighup
# krb_caseins_users = off

# Password Encryption
# ------------------
# Algorithm to use for encrypting passwords stored in the database.
# 'scram-sha-256' is the most secure option and recommended for new deployments.
# 'md5' may be needed for compatibility with older clients.
#
# context: user
# password_encryption = 'scram-sha-256'

#------------------------------------------------------------------------------
# SCRAM AUTHENTICATION
#------------------------------------------------------------------------------

# Sets the iteration count for SCRAM secret generation.
# Higher values increase security at the cost of CPU time during authentication.
# The default (4096) provides a good balance between security and performance.
#
# context: user
# scram_iterations = 4096

#------------------------------------------------------------------------------
# PRIVILEGE MANAGEMENT
#------------------------------------------------------------------------------

# Sets whether a CREATEROLE user automatically grants the role to themselves,
# and with which options. Empty string means no automatic self-grant.
#
# context: user
# createrole_self_grant = ''

#------------------------------------------------------------------------------
# RELATION ACCESS RESTRICTIONS
#------------------------------------------------------------------------------

# Prohibits access to non-system relations of specified kinds.
# Comma-separated list of relation kinds to prohibit access to
# (e.g., 'view,sequence'). Empty string means no restrictions.
#
# context: user
# restrict_nonsystem_relation_kind = ''

#------------------------------------------------------------------------------
# TCP KEEPALIVES
#------------------------------------------------------------------------------

# TCP keepalives help detect dead client connections. The following settings
# control how keepalives work. Proper configuration prevents hanging connections
# and improves reliability, especially on unreliable networks.

# Number of seconds of inactivity before sending a keepalive packet.
# A value of 0 uses the system default.
#
# context: user
# tcp_keepalives_idle = 0

# Number of seconds between retransmitting keepalive packets.
# A value of 0 uses the system default.
#
# context: user
# tcp_keepalives_interval = 0

# Maximum number of keepalive retransmits before dropping the connection.
# A value of 0 uses the system default.
#
# context: user
# tcp_keepalives_count = 0

# The TCP user timeout value (in milliseconds). This specifies how long
# transmitted data may remain unacknowledged before the connection is dropped.
# A value of 0 uses the system default.
#
# context: user
# tcp_user_timeout = 0

# Client connection check interval in milliseconds.
# Sets how often to check if a connection has been dropped during query execution.
# 0 disables the check. Useful for detecting network problems during long queries.
#
# context: user
# client_connection_check_interval = 0

#------------------------------------------------------------------------------
# RESOURCE USAGE
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# BUFFER USAGE
#------------------------------------------------------------------------------

# Sets the buffer pool size for VACUUM, ANALYZE, and autovacuum operations.
# Limits memory consumption for these operations to prevent them from using
# too much memory and impacting other database activities.
#
# context: user
# vacuum_buffer_usage_limit = 2048kB

#------------------------------------------------------------------------------
# NOTIFICATION SYSTEM RESOURCES
#------------------------------------------------------------------------------

# Sets the maximum number of allocated pages for NOTIFY/LISTEN queue.
# Increase this if you make heavy use of PostgreSQL's asynchronous notification
# system to prevent notification loss.
#
# context: postmaster
# max_notify_queue_pages = 1048576

# Sets the size of the dedicated buffer pool used for the LISTEN/NOTIFY message cache.
# Provides memory for caching notification messages.
#
# context: postmaster
# notify_buffers = 16MB

#------------------------------------------------------------------------------
# TRANSACTION TRACKING
#------------------------------------------------------------------------------

# Sets the size of the dedicated buffer pool used for the commit timestamp cache.
# Used when track_commit_timestamp is enabled.
# Specify 0 to have this value determined as a fraction of shared_buffers.
#
# context: postmaster
# commit_timestamp_buffers = 32MB

# Sets the size of the dedicated buffer pool used for the transaction status cache.
# Specify 0 to have this value determined as a fraction of shared_buffers.
#
# context: postmaster
# transaction_buffers = 32MB
  
# Sets the size of the dedicated buffer pool used for the subtransaction cache.
# Specify 0 to have this value determined as a fraction of shared_buffers.
#
# context: postmaster
# subtransaction_buffers = 32MB

# Sets the size of the dedicated buffer pool used for the serializable transaction cache.
# Provides memory for tracking serializable transactions.
#
# context: postmaster
# serializable_buffers = 32MB

#------------------------------------------------------------------------------
# MULTIXACT TRACKING
#------------------------------------------------------------------------------

# Sets the size of the dedicated buffer pool used for the MultiXact member cache.
# MultiXact is used when multiple transactions lock the same row.
#
# context: postmaster
# multixact_member_buffers = 32MB

# Sets the size of the dedicated buffer pool used for the MultiXact offset cache.
# Used for tracking MultiXact IDs.
#
# context: postmaster
# multixact_offset_buffers = 16MB

#------------------------------------------------------------------------------
# IO CONCURRENCY AND REDUCTION
#------------------------------------------------------------------------------

# Limit on the size of data reads and writes.
# Reduces the risk of read/write amplification by combining nearby I/O operations.
# Higher values allow more operations to be combined, but may increase latency.
#
# context: user
# io_combine_limit = 16MB



#------------------------------------------------------------------------------
# MEMORY USAGE
#------------------------------------------------------------------------------

# Memory configuration is critical for PostgreSQL performance. Proper settings
# help avoid disk I/O and improve query execution speed.

#------------------------------------------------------------------------------
# SHARED BUFFERS AND MEMORY
#------------------------------------------------------------------------------

# The amount of memory PostgreSQL uses for shared memory buffers.
# This is the main memory area for caching data pages.
#
# Recommended starting values:
# - For dedicated database servers: 25% of system RAM
# - For shared servers: 15-20% of system RAM
# - For small systems (<1GB RAM): 128MB-256MB
#
# Increasing this value generally improves performance, but values above 8GB
# often show diminishing returns. Very large values can cause issues on some OS.
#
# NOTE: The OS kernel may need to be configured to allow large shared memory
# segments. See PostgreSQL documentation on "Kernel Resource Usage".
#
# context: postmaster
# shared_buffers = 128MB

# Determines how shared memory segments are implemented.
# Options include:
# - posix: POSIX shared memory (most common and recommended)
# - sysv: System V shared memory
# - windows: Windows shared memory
# - mmap: Memory mapped files
#
# 'posix' is generally the best option for modern systems.
#
# context: postmaster
# shared_memory_type = 'mmap'

# Selects the method for dynamic shared memory allocation.
# Options include:
# - posix: POSIX shared memory (most common and recommended)
# - sysv: System V shared memory
# - windows: Windows shared memory
# - mmap: Memory-mapped files
#
# 'posix' is generally the best option for modern systems.
#
# context: postmaster
# dynamic_shared_memory_type = 'posix'

# Minimum amount of dynamic shared memory to reserve at startup.
# This pre-allocates shared memory to avoid fragmentation.
#
# context: postmaster
# min_dynamic_shared_memory = 0MB

#------------------------------------------------------------------------------
# DISK AND MEMORY BUFFERS
#------------------------------------------------------------------------------

# The amount of memory used for caching data that's not in shared_buffers.
# This is per-operation, not per-server or per-session. The default is
# typically adequate; large complex queries may benefit from larger values.
#
# Recommended settings:
# - For OLTP workloads: 1-4MB
# - For OLAP/reporting: 4-16MB or higher
# - For mixed workloads: 4-8MB
#
# WARNING: Setting too high can cause excessive memory usage when many
# concurrent operations are running.
#
# context: user
# work_mem = 4MB

# Multiplier applied to work_mem for hash-based operations like hash joins.
# A value of 1.0 means use the same amount as work_mem.
# Values >1.0 allocate more memory for hash operations.
#
# context: user
# hash_mem_multiplier = 1.0

# Maximum number of tuples to be sorted using replacement selection.
# Larger values improve sorting performance for large datasets that don't
# fit in memory. Generally, should be left at the default unless you have
# specific sorting performance issues.
#
# context: user
# replacement_sort_tuples = 150000

# Memory used for maintenance operations like VACUUM, CREATE INDEX, etc.
# This is per operation, not total, so can be set higher than work_mem.
#
# Recommended settings:
# - Small servers: 64MB
# - Medium servers: 128-256MB
# - Large servers: 256MB-1GB
#
# context: user
# maintenance_work_mem = 64MB

# Memory used for each autovacuum worker process. If left at -1, it defaults
# to the value of maintenance_work_mem.
#
# context: sighup
# autovacuum_work_mem = -1

# Memory limit for temporary buffers used by each database session.
# These are in-memory sorting areas and hash tables for queries that can't
# fit in shared_buffers. Default is usually adequate for small queries.
#
# Increase if you have complex queries with many joins or if you see
# temporary file warnings in logs.
#
# context: user
# temp_buffers = 8MB

# Memory used for logical decoding, which is used for change data capture
# and logical replication.
#
# context: user
# logical_decoding_work_mem = 64MB

#------------------------------------------------------------------------------
# KERNEL RESOURCES AND HUGE PAGES
#------------------------------------------------------------------------------

# Whether to use Linux huge pages if available.
# Options:
# - try: Try to use huge pages, but fall back to regular pages if necessary
# - on: Use huge pages, fail if they're not available
# - off: Don't use huge pages
#
# Huge pages can significantly improve performance on large memory systems
# by reducing TLB (Translation Lookaside Buffer) misses.
#
# NOTE: Requires kernel configuration for huge pages.
#
# context: postmaster
# huge_pages = try

# Specifies the size of huge page that should be requested.
# A value of 0 lets the system choose the default huge page size.
#
# context: postmaster
# huge_page_size = 0

# Maximum stack depth in kilobytes. This is a safety limit to prevent
# server crashes from infinite recursion or excessive memory usage.
# If set too low, complex queries might fail.
#
# context: superuser
# max_stack_depth = 2MB

# Controls the total amount of temporary files a single PostgreSQL process
# can use. Set in kilobytes. -1 means no limit.
#
# This helps prevent runaway queries from filling your disk. Consider setting
# based on available disk space for temp files.
#
# context: superuser
# temp_file_limit = -1

# Maximum number of files that can be open per process. Default usually
# works well, but may need increasing for applications with many connections
# or many tables.
#
# context: postmaster
# max_files_per_process = 1000

#------------------------------------------------------------------------------
# WRITE AHEAD LOG (WAL)
#------------------------------------------------------------------------------

# The Write-Ahead Log (WAL) is critical for PostgreSQL's durability and
# crash recovery capabilities. It records all changes before they're
# written to the data files, allowing PostgreSQL to recover from crashes
# and power failures without data loss.

#------------------------------------------------------------------------------
# WAL SETTINGS
#------------------------------------------------------------------------------

# Sets the level of information written to the WAL.
# Options:
# - minimal: Writes only information needed for crash recovery (lowest overhead)
# - replica: Adds information needed for running read-only operations on a standby
# - logical: Adds information needed for logical decoding (highest overhead)
# [Definition] Logical decoding: The process of extracting changes from the WAL
#
# Use 'minimal' for standalone servers with no replication
# Use 'replica' when using physical replication
# Use 'logical' when using logical replication
#
# context: postmaster
# wal_level = 'replica'

# The number of WAL segments (16MB files by default) to keep for standby servers.
# This is deprecated and replaced by wal_keep_size.
#
# context: sighup
# wal_keep_segments = 0

# Specifies the size of WAL files that should be kept to allow standby
# servers to catch up. Setting this helps ensure standbys don't fall behind
# too far when there's a high write load.
#
# context: sighup
# wal_keep_size = 0MB

# Maximum size of WAL files held by replication slots. Once this limit is
# reached, WAL for replication slots will no longer be retained.
# A value of -1 means unlimited.
#
# WARNING: Setting -1 means WAL files are retained indefinitely for inactive
# replication slots, which can fill up your disk.
#
# context: postmaster
# max_slot_wal_keep_size = -1

# Method for synchronizing the data directory before crash recovery.
# Options:
# - fsync: Calls fsync on all files (safest)
# - syncfs: Syncs entire filesystem (may be faster on some systems)
#
# context: postmaster
# recovery_init_sync_method = 'fsync'

#------------------------------------------------------------------------------
# CHECKPOINTS
#------------------------------------------------------------------------------

# Checkpoints write all dirty buffers to disk, ensuring data file consistency.
# Properly tuned checkpoints balance safety and performance.

# Maximum size that WAL can reach before a checkpoint is forced.
# Larger values mean fewer checkpoints but more recovery time after a crash.
#
# Recommended settings:
# - Small systems: 1GB
# - Medium systems: 2-4GB
# - Large systems: 8-16GB
#
# context: sighup
# max_wal_size = 1GB

# Minimum size to shrink the WAL to after a checkpoint.
# Setting this prevents WAL from constantly growing and shrinking
# between checkpoints.
#
# context: sighup
# min_wal_size = 80MB

# Maximum time between automatic WAL checkpoints, in seconds.
# Lower values reduce recovery time but increase I/O load during normal
# operation.
#
# Recommended settings:
# - For durability emphasis: 5min
# - For performance emphasis: 15-30min
#
# context: sighup
# checkpoint_timeout = 5min

# Target checkpoint completion time, as fraction of checkpoint interval.
# Controls how quickly checkpoint I/O is performed.
#
# Lower values concentrate I/O more (higher peak impact, faster completion)
# Higher values spread I/O more (lower peak impact, longer completion)
#
# Recommended settings:
# - For SSDs or high-performance storage: 0.7-0.9
# - For HDDs or storage with limited I/O: 0.5-0.7
#
# context: sighup
# checkpoint_completion_target = 0.9

# Number of 16MB WAL segments that can fill faster than checkpoint_timeout
# before a warning is logged. Helps detect when WAL is filling too quickly.
#
# context: sighup
# checkpoint_warning = 30s

# Number of pages after which previously performed writes are flushed to disk
# during checkpoint operations.
#
# Lower values can reduce spikes in I/O.
#
# context: sighup
# checkpoint_flush_after = 256kB

#------------------------------------------------------------------------------
# ARCHIVING
#------------------------------------------------------------------------------

# WAL archiving copies WAL files to a safe location for long-term storage,
# enabling point-in-time recovery and backup strategies.

# Allows archiving of WAL files using archive_command.
# Options:
# - off: No archiving (default)
# - on: Enables archiving
# - always: Archives even in standby mode
#
# context: postmaster
# archive_mode = off

# Shell command to execute to archive a WAL file.
# %p is replaced with the path of the file to archive
# %f is replaced with only the file name
#
# Example: 'cp %p /mnt/server/archivedir/%f'
#
# The command should return zero exit status only if successful.
#
# context: sighup
# archive_command = ''

# Maximum time to wait before forcing a switch to a new WAL file.
# This ensures WAL files are archived at regular intervals even during
# periods of low write activity.
#
# context: sighup
# archive_timeout = 0

# Command executed at every restart point during recovery.
# This is useful for cleanup operations related to archived WAL files.
#
# context: sighup
# archive_cleanup_command = ''

#------------------------------------------------------------------------------
# WAL PERFORMANCE
#------------------------------------------------------------------------------

# Memory buffers for WAL. The default (-1) is 1/32 of shared_buffers,
# with minimum 64kB and maximum 16MB. Larger values can improve WAL
# performance for busy systems with many concurrent transactions.
#
# context: postmaster
# wal_buffers = -1

# Number of pages after which previously performed writes are flushed to disk
# during WAL flush operations. This helps smooth out disk I/O.
#
# context: sighup
# wal_writer_flush_after = 1MB

# Time between WAL flushes performed in the WAL writer process.
# Lower values reduce risk of data loss but increase I/O operations.
#
# context: sighup
# wal_writer_delay = 200ms

# Size threshold for WAL file operations. For WAL writes smaller than this,
# the full WAL record is written. For larger writes, only a hint bit is set
# and the OS is trusted to flush the page to disk.
#
# Higher values can improve performance but increase risk of data loss
# in case of OS crash.
#
# context: sighup
# wal_skip_threshold = 2MB

# Whether WAL writer should compress full-page writes stored in WAL.
# Options:
# - off: No compression
# - on: Use compression
# - pglz: Use PGLZ compression
#
# Compression reduces WAL size but uses more CPU.
#
# context: superuser
# wal_compression = off

# Forces synchronization of updates to disk.
# CRITICAL SAFETY SETTING: Turning this off risks data corruption in case
# of power failure or system crash.
#
# Only turn off in test environments or if data loss is acceptable.
#
# context: sighup
# fsync = on

# Writes full pages to WAL when first modified after a checkpoint.
# This is essential for crash recovery. Turning off saves WAL space
# but risks data corruption after a crash if your storage or OS cannot
# guarantee atomic page writes.
#
# DANGER: Setting to 'off' risks data corruption. Only change if you
# fully understand the risks.
#
# context: sighup
# full_page_writes = on

# Writes full pages to WAL when first modified after a checkpoint, even for
# non-critical modifications like hint bits. Increases WAL volume but provides
# additional safety for some scenarios.
#
# context: postmaster
# wal_log_hints = off

# Method used for forcing WAL updates to disk.
# Options depend on OS, but common ones include:
# - fsync: Call fsync() at each commit (most portable)
# - fdatasync: Call fdatasync() at each commit (avoids some I/O)
# - open_datasync: Use O_DSYNC flag when opening files
# - open_sync: Use O_SYNC flag when opening files
#
# PostgreSQL automatically selects the best available method for your OS.
# Only change if you're experiencing specific WAL performance issues.
#
# context: sighup
# wal_sync_method = 'fsync'

# Whether to initialize WAL files with zeros when they're created.
# Setting to 'on' (default) is safer but slower. Setting to 'off'
# improves performance but might cause problems on some filesystems.
#
# context: sighup
# wal_init_zero = on

# Whether to recycle WAL files by renaming them instead of creating new ones.
# This saves file creation overhead. Only disable if you have file system
# issues with renaming files.
#
# context: sighup
# wal_recycle = on

# Microseconds to delay between transaction commit and WAL flush to disk.
# This aggregates multiple commits into a single flush operation,
# improving throughput at the cost of slightly increased risk of data loss.
#
# A value of 0 disables the delay.
#
# Only effective when many connections are committing at the same time.
# Works with commit_siblings parameter.
#
# context: superuser
# commit_delay = 0

# Minimum number of concurrent open transactions before applying commit_delay.
# commit_delay is only applied when at least this many transactions are active.
#
# context: user
# commit_siblings = 5

# Controls synchronization level for transaction commits.
# Options:
# - on: Wait for WAL flush to disk (safest, default)
# - remote_apply: Wait for standbys to apply transaction
# - remote_write: Wait for standbys to write to their WAL
# - local: Wait for local WAL write only
# - off: Don't wait for WAL writes (dangerous!)
#
# WARNING: 'off' can lead to data loss in event of server crash.
# Only use when performance is more important than data durability.
#
# context: user
# synchronous_commit = on

#------------------------------------------------------------------------------
# REPLICATION
#------------------------------------------------------------------------------

# PostgreSQL supports various replication methods for high availability,
# disaster recovery, and read scaling.

#------------------------------------------------------------------------------
# SENDING SERVERS
#------------------------------------------------------------------------------

# Maximum number of simultaneously running WAL sender processes.
# Each physical standby server requires one WAL sender on the primary.
#
# context: postmaster
# max_wal_senders = 10

# Maximum number of simultaneously defined replication slots.
# Each physical or logical replication connection usually needs its own slot.
#
# context: postmaster
# max_replication_slots = 10

# Maximum time (in milliseconds) to wait for WAL replication. If a standby
# server falls behind by more than this time, the primary will stop waiting
# and proceed with operations.
#
# context: sighup
# wal_sender_timeout = 60s

#------------------------------------------------------------------------------
# PRIMARY SERVER
#------------------------------------------------------------------------------

# The number of concurrent connections reserved for synchronous standbys
# and the names of standbys that can be synchronous.
#
# Format: [num_sync, ]standby_name [, ...]
# Examples:
#   '2 (s1, s2, s3)' - Wait for any 2 of the 3 listed standbys
#   '1 (s1, s2)' - Wait for either s1 or s2
#   's1' - Wait for just s1
#
# Empty string means asynchronous replication (no waiting for standbys).
#
# context: sighup
# synchronous_standby_names = ''

# Number of transactions by which VACUUM and HOT cleanup should be deferred.
# This helps standby servers stay closer to the primary by delaying cleanup
# operations that might cause conflicts.
#
# context: sighup
# vacuum_defer_cleanup_age = 0

#------------------------------------------------------------------------------
# STANDBY SERVERS
#------------------------------------------------------------------------------

# Allows connections and queries during recovery/replication.
# This enables read-only queries on standby servers.
#
# context: postmaster
# hot_standby = on

# The connection string to be used to connect to the sending (primary) server.
# Example: 'host=192.168.1.50 port=5432 user=replication password=mypassword'
#
# context: postmaster
# primary_conninfo = ''

# The name of the replication slot to use on the primary.
# Using a slot ensures the primary keeps WAL needed by this standby.
#
# context: postmaster
# primary_slot_name = ''

# Maximum delay before canceling queries when a hot standby server is
# processing archived WAL data. This limits how far behind a standby
# can fall before long queries are canceled to allow recovery to catch up.
#
# context: sighup
# max_standby_archive_delay = 30s

# Maximum delay before canceling queries when a hot standby server is
# processing streamed WAL data. Similar to max_standby_archive_delay but
# for streaming replication.
#
# context: sighup
# max_standby_streaming_delay = 30s

# Specifies a trigger file name whose presence ends recovery in the
# standby and promotes it to primary.
#
# context: postmaster
# promote_trigger_file = ''

# Whether to send info from standby to primary about queries being executed
# on the standby. Helps avoid query conflicts but increases write activity
# on the primary.
#
# context: sighup
# hot_standby_feedback = off

# Maximum interval between WAL receiver status reports to the primary.
# These reports tell the primary about the standby's WAL processing progress.
#
# context: sighup
# wal_receiver_status_interval = 10s

# Maximum time to wait before retrying to retrieve WAL after a failed attempt.
# Larger values reduce load on the primary when WAL isn't available.
#
# context: sighup
# wal_retrieve_retry_interval = 5s

# Maximum time to wait for the sending server to send WAL data.
# If no data is received within this time, the receiver terminates connection.
#
# context: sighup
# wal_receiver_timeout = 60s

# Whether a WAL receiver should create a temporary replication slot if
# no permanent slot is configured. This helps ensure WAL is retained
# even if the standby disconnects temporarily.
#
# context: sighup
# wal_receiver_create_temp_slot = off

#------------------------------------------------------------------------------
# RECOVERY TARGETS
#------------------------------------------------------------------------------

# These parameters control where recovery should stop.
# They're typically used during point-in-time recovery.

# Sets the LSN (Log Sequence Number) to recover to. Recovery will stop
# at this exact WAL position.
#
# context: postmaster
# recovery_target_lsn = ''

# Sets a named restore point to recover to. These are created with
# pg_create_restore_point() function.
#
# context: postmaster
# recovery_target_name = ''

# Sets the timestamp to recover to. Recovery will stop at this time.
# Format: '2020-01-01 12:00:00 GMT'
#
# context: postmaster
# recovery_target_time = ''

# Sets the transaction ID to recover to. Recovery will stop at this transaction.
# Can use 'latest' as a special value.
#
# context: postmaster
# recovery_target_xid = ''

# Sets whether recovery target is inclusive or exclusive.
# If true, stop at specified recovery target (inclusive).
# If false, stop just before the recovery target (exclusive).
#
# context: postmaster
# recovery_target_inclusive = on

# Specifies the timeline to recover into.
# 'latest' recovers along the same timeline as the base backup.
# A specific timeline ID can be specified to recover along a different branch.
#
# context: postmaster
# recovery_target_timeline = 'latest'

# Set to 'immediate' to end recovery as soon as a consistent state is reached.
# Useful for creating a copy of the database quickly.
#
# context: postmaster
# recovery_target = ''

# Sets the minimum delay to apply changes during recovery.
# Useful for standbys when you want to delay replication to allow
# for error recovery on the primary.
#
# context: postmaster
# recovery_min_apply_delay = 0

#------------------------------------------------------------------------------
# RECOVERY COMMANDS
#------------------------------------------------------------------------------

# Shell command to execute to retrieve archived WAL files.
# %f is the name of the file to retrieve.
# %p is the path where to place it.

# Example: 'cp /mnt/server/archivedir/%f %p'

# context: postmaster
# restore_command = ''

# Shell command that will be executed once at the end of recovery.
# Useful for cleanup tasks or notification that recovery is complete.
#
# context: postmaster
# recovery_end_command = ''

# Sets the action to perform upon reaching the recovery target.
# Options:
# - pause: Pause recovery (default) - allows inspection before proceeding
# - promote: Promote to primary - ends recovery and becomes writable
# - shutdown: Stop the server after recovery
#
# context: postmaster
# recovery_target_action = 'pause'

#------------------------------------------------------------------------------
# LOGICAL REPLICATION
#------------------------------------------------------------------------------

# Maximum number of logical replication worker processes.
# Each subscription typically needs its own apply worker.
#
# context: postmaster
# max_logical_replication_workers = 4

# Maximum number of table synchronization workers per subscription.
# These are additional temporary workers used during initial table sync.
#
# context: sighup
# max_sync_workers_per_subscription = 2

#------------------------------------------------------------------------------
# WAL AND RECOVERY
#------------------------------------------------------------------------------

# These settings control how WAL is managed and recovered. 

#------------------------------------------------------------------------------
# WAL RECOVERY
#------------------------------------------------------------------------------

# Prefetch referenced blocks during recovery.
# Options:
# - off: No prefetching
# - on: Always attempt prefetching
# - try: Attempt prefetching if supported (default)
#
# This can significantly improve recovery performance by reading ahead
# in the WAL to find references to data blocks not yet in the buffer cache.
#
# context: sighup
# recovery_prefetch = try

#------------------------------------------------------------------------------
# WAL DECODING
#------------------------------------------------------------------------------

# Buffer size for reading ahead in the WAL during recovery.
# Maximum distance to read ahead in the WAL to prefetch referenced data blocks.
# Larger values can improve recovery performance at the cost of memory usage.
#
# context: postmaster
# wal_decode_buffer_size = 524288B

#------------------------------------------------------------------------------
# WAL SUMMARIZATION
#------------------------------------------------------------------------------

# Starts the WAL summarizer process to enable incremental backup.
# When enabled, a background process produces summary files that allow
# incremental backups to identify changed blocks without scanning all WAL.
#
# context: sighup
# summarize_wal = off

# Time for which WAL summary files should be kept, in minutes.
# Controls how long summarized WAL information is retained.
#
# context: sighup
# wal_summary_keep_time = 14400min

#------------------------------------------------------------------------------
# QUERY TUNING
#------------------------------------------------------------------------------

# This section controls the query planner/optimizer that determines
# how queries should be executed.

#------------------------------------------------------------------------------
# PLANNER METHOD CONFIGURATION
#------------------------------------------------------------------------------

# These parameters enable or disable specific query plan types.
# They're useful for debugging or working around specific performance issues.
# In general, you should leave these at their defaults unless you have
# a specific reason to change them.

# Enable/disable sequential scan plans. Sequential scans read the entire
# table in order.
#
# context: user
# enable_seqscan = on

# Enable/disable index scan plans. Index scans use an index to look up rows.
#
# context: user
# enable_indexscan = on

# Enable/disable bitmap scan plans. Bitmap scans use an index to create a bitmap
# of matching pages, then fetch only those pages.
#
# context: user
# enable_bitmapscan = on

# Enable/disable index-only scan plans. Index-only scans get data from the
# index without accessing the table.
#
# context: user
# enable_indexonlyscan = on

# Enable/disable TID scan plans. TID scans fetch rows directly by their
# physical location (tuple ID).
#
# context: user
# enable_tidscan = on

# Enable/disable nested loop join plans. Nested loop joins work by scanning
# one table and looking up matching rows in another.
#
# context: user
# enable_nestloop = on

# Enable/disable merge join plans. Merge joins work by scanning both tables
# in sorted order and merging the results.
#
# context: user
# enable_mergejoin = on

# Enable/disable hash join plans. Hash joins build a hash table from one table
# and probe it with rows from another.
#
# context: user
# enable_hashjoin = on

# Enable/disable hash aggregation plans. Hash aggregation builds a hash table
# for grouping operations.
#
# context: user
# enable_hashagg = on

# Enable/disable materialization. Materialization stores intermediate results
# in memory or on disk.
#
# context: user
# enable_material = on

# Enable/disable explicit sort steps.
#
# context: user
# enable_sort = on

# Enable/disable incremental sort steps. Incremental sort can be more efficient
# than full sort for some operations.
#
# context: user
# enable_incremental_sort = on

# Enable/disable partitionwise aggregation and grouping.
# This can improve performance for queries on partitioned tables.
#
# context: user
# enable_partitionwise_aggregate = off

# Enable/disable partitionwise join.
# This can improve performance for joins on partitioned tables.
#
# context: user
# enable_partitionwise_join = off

# Enable/disable plan-time and execution-time partition pruning.
# This eliminates unnecessary partitions from query plans.
#
# context: user
# enable_partition_pruning = on

# Enable/disable parallel append plans.
# These allow parallel execution of UNION ALL queries.
#
# context: user
# enable_parallel_append = on

# Enable/disable parallel hash plans.
# These allow parallel execution of hash joins.
#
# context: user
# enable_parallel_hash = on

# Enable/disable gather merge plans.
# These merge results from parallel workers while preserving order.
#
# context: user
# enable_gathermerge = on

# Enable/disable memoization. Memoization caches results of expressions
# to avoid recalculating them.
#
# context: user
# enable_memoize = on

# Enable/disable async append plans. These can improve performance
# for queries with UNION ALL by allowing asynchronous execution.
#
# context: user
# enable_async_append = on


#------------------------------------------------------------------------------
# PLANNER COST CONSTANTS
#------------------------------------------------------------------------------

# These parameters influence the cost estimates made by the query planner.
# Adjusting them can improve plan selection for your specific hardware
# and workload.

# Planner's estimate of the cost of processing each tuple (row).
# This represents CPU cost for processing a row.
#
# context: user
# cpu_tuple_cost = 0.01

# Planner's estimate of the cost of processing each index entry during
# an index scan. This represents CPU cost for processing an index entry.
#
# context: user
# cpu_index_tuple_cost = 0.005

# Planner's estimate of the cost of processing each operator or function call.
# This represents CPU cost for evaluating operators and functions.
#
# context: user
# cpu_operator_cost = 0.0025

# Planner's assumption about the size of the disk cache (effective_cache_size).
# This is used to estimate the cost of using an index. Higher values
# make index scans look less expensive relative to sequential scans.
#
# For dedicated database servers, set to 50-75% of total system memory.
# For shared servers, set to 25-50% of total system memory.
#
# Note: This does NOT allocate memory, it just tells the planner how much
# cache is expected to be available.
#
# context: user
# effective_cache_size = 4GB

# Number of simultaneous requests that can be handled efficiently by the
# disk subsystem. Used for estimating cost of using an index.
#
# For RAID arrays, set approximately to the number of active drives.
# For SSDs, set much higher (e.g., 100-200) since they can handle many
# concurrent requests.
# For single spinning disks, leave at the default of 1.
#
# context: user
# effective_io_concurrency = 1

# A variant of effective_io_concurrency that is used for maintenance operations
# like VACUUM. Can be set higher than effective_io_concurrency if maintenance
# operations can use more I/O concurrency.
#
# context: user
# maintenance_io_concurrency = 10

# Cost of a non-sequentially fetched disk page.
# Represents the extra cost of random I/O compared to sequential I/O.
#
# For SSDs or storage with good random I/O performance, set lower (1.1-2.0).
# For HDDs or storage with poor random I/O, leave at the default (4.0).
#
# Lower values make index scans look less expensive relative to sequential scans.
#
# context: user
# random_page_cost = 4.0

# Cost of a sequentially fetched disk page.
# This is the baseline I/O cost that other costs are relative to.
# Generally should be left at the default.
#
# context: user
# seq_page_cost = 1.0

# Sets the planner's estimate of the cost of starting up worker processes
# for parallel query. Higher values make parallel query less likely to be used.
#
# context: user
# parallel_setup_cost = 1000

# Sets the planner's estimate of the cost of passing each tuple from worker
# to master backend. Higher values make parallel query less likely to be used.
#
# context: user
# parallel_tuple_cost = 0.1

#------------------------------------------------------------------------------
# ADDITIONAL PLANNER OPTIONS
#------------------------------------------------------------------------------

# Enables reordering of GROUP BY keys.
# When enabled, the planner may reorder GROUP BY keys to improve performance.
# Disable only if you need a specific GROUP BY order for application reasons.
#
# context: user
# enable_group_by_reordering = on

# Enables the planner's ability to produce plans that provide presorted input
# for ORDER BY / DISTINCT aggregate functions. This can avoid explicit sorting
# steps when data is already appropriately ordered.
#
# context: user
# enable_presorted_aggregate = on

# Sets the planner's estimate of the average size of a recursive query's
# working table. Higher values make the planner estimate that recursive
# queries will use more space.
#
# context: user
# recursive_worktable_factor = 10


#------------------------------------------------------------------------------
# REPLICATION SLOT SYNCHRONIZATION
#------------------------------------------------------------------------------

# Enables a physical standby to synchronize logical failover replication slots
# from the primary server. When enabled, logical replication slots created on
# the primary are automatically copied to the standby server, ensuring logical
# replication can continue if the standby is promoted.
#
# context: sighup
# sync_replication_slots = off

#------------------------------------------------------------------------------
# LOGICAL REPLICATION STREAMING
#------------------------------------------------------------------------------

# Controls how streaming of in-progress transactions for logical replication works.
# Options:
# - buffered: Buffer changes in memory and write them when the transaction ends (default)
# - immediate: Stream changes as they happen without waiting for commit
#
# context: user
# debug_logical_replication_streaming = buffered

#------------------------------------------------------------------------------
# SYNCHRONIZED STANDBY SLOTS
#------------------------------------------------------------------------------

# Lists streaming replication standby server replication slot names that logical
# WAL sender processes will wait for. Logical WAL sender processes will send
# decoded changes to output plugins only after the specified replication slots
# have confirmed receiving WAL.
#
# context: sighup
# synchronized_standby_slots = ''


#------------------------------------------------------------------------------
# PARALLEL QUERY
#------------------------------------------------------------------------------

# Maximum number of worker processes per executor node (parallel operation).
# This limits the degree of parallelism for a single query.
#
# Good starting points based on CPU cores:
# - 4 cores: 2
# - 8 cores: 4
# - 16+ cores: 6-8
#
# context: user
# max_parallel_workers_per_gather = 2

# Maximum number of parallel workers that can be active at one time.
# This limits the total system-wide parallelism.
#
# Recommended setting: 2 × number of CPU cores
#
# context: user
# max_parallel_workers = 8

# Maximum number of parallel processes per maintenance operation.
# This affects parallel index builds, vacuum, etc.
#
# context: user
# max_parallel_maintenance_workers = 2

# Controls whether Gather and Gather Merge also run subplans.
# When on, the leader process also executes part of the plan, which is
# more CPU-efficient but may reduce parallelism.
#
# context: user
# parallel_leader_participation = on

# Forces use of parallel query facilities (for testing).
# Options:
# - off: Only use parallel queries when appropriate (default)
# - on: Always consider parallel plans for eligible queries (use for testing)
# - regress: Behave like 'on' but with modified output formatting (for testing)
#
# context: user
# force_parallel_mode = off

# Minimum table size for parallel scan. Tables smaller than this won't use
# parallel scan.
#
# context: user
# min_parallel_table_scan_size = 8MB

# Minimum index size for parallel scan. Indexes smaller than this won't use
# parallel scan.
#
# context: user
# min_parallel_index_scan_size = 512kB

#------------------------------------------------------------------------------
# GENERIC PLANNER OPTIONS
#------------------------------------------------------------------------------

# Default statistics target. This controls the detail of statistics collected
# for table columns. Higher values improve plan quality but increase ANALYZE time.
#
# Recommended values:
# - General-purpose: 100 (default)
# - Complex analytical queries: 100-500
#
# Can be overridden per-column using ALTER TABLE ... ALTER COLUMN ... SET STATISTICS
#
# context: user
# default_statistics_target = 100

# Enables the planner to use constraints to optimize queries.
# Options:
# - off: Never use constraint information
# - on: Use constraints for all tables
# - partition: Use constraints for partitioned tables only (default)
#
# context: user
# constraint_exclusion = partition

# Sets the planner's estimate of the fraction of a cursor's rows that will
# be retrieved. This affects cost estimation for plans involving cursors.
#
# Lower values favor plans that are efficient for partial retrieval.
# Higher values favor plans that are efficient for complete retrieval.
#
# context: user
# cursor_tuple_fraction = 0.1

# Sets the FROM-list size beyond which subqueries are not collapsed into upper
# query. Large joins are usually better executed by keeping subqueries separate.
#
# context: user
# from_collapse_limit = 8

# Sets the FROM-list size beyond which JOIN constructs are not flattened.
# Similar to from_collapse_limit, but applies to explicit JOIN syntax.
#
# context: user
# join_collapse_limit = 8

# Controls the planner's selection of custom or generic plan.
# Options:
# - auto: Let the planner decide (default)
# - custom_plan: Always use custom plans
# - generic_plan: Always use generic plans
#
# context: user
# plan_cache_mode = auto

# Compute query identifiers. These are useful for tracking queries in
# monitoring tools and extensions like pg_stat_statements.
# Options:
# - off: Don't compute query IDs
# - on: Always compute query IDs
# - auto: Compute query IDs if needed by a monitoring tool (default)
#
# context: postmaster
# compute_query_id = auto

#------------------------------------------------------------------------------
# GENETIC QUERY OPTIMIZER
#------------------------------------------------------------------------------

# The Genetic Query Optimizer (GEQO) uses genetic algorithms to plan queries
# with large numbers of tables. It's generally faster than exhaustive planning
# for queries with many tables, but may produce slightly lower-quality plans.

# Enable or disable genetic query optimization.
# Usually should be left enabled.
#
# context: user
# geqo = on

# Use genetic query optimization for queries with at least this many FROM items.
# Queries below this threshold use the standard exhaustive planning.
#
# context: user
# geqo_threshold = 12

# GEQO: Effort is used to set the default for other GEQO parameters.
# Higher values use more effort (time) for better plans.
#
# context: user
# geqo_effort = 5

# GEQO: Number of individuals in the population. Larger values give more
# diverse solutions but increase planning time.
#
# A value of 0 uses a suitable default based on geqo_effort.
#
# context: user
# geqo_pool_size = 0

# GEQO: Number of iterations of the algorithm. Larger values potentially
# give better plans but increase planning time.
#
# A value of 0 uses a suitable default based on geqo_effort.
#
# context: user
# geqo_generations = 0

# GEQO: Selective pressure within the population. Values between 1.5 and 2.0
# perform best in most cases.
#
# context: user
# geqo_selection_bias = 2.0

# GEQO: Seed for random path selection. Changing this may produce better
# plans for specific queries by chance.
#
# context: user
# geqo_seed = 0.0

#------------------------------------------------------------------------------
# QUERY EXECUTION
#------------------------------------------------------------------------------

# JIT compilation can accelerate execution of complex queries by compiling
# expressions into native code.

# Allow JIT compilation.
# Enabling improves performance for complex queries but increases planning time.
#
# context: user
# jit = on

# Perform JIT compilation if query is more expensive than this.
# Higher values limit JIT to more complex queries.
#
# context: user
# jit_above_cost = 100000

# Optimize JIT-compiled functions if query is more expensive than this.
# Higher-level optimizations improve execution speed but increase compilation time.
#
# context: user
# jit_optimize_above_cost = 500000

# Perform JIT inlining if query is more expensive than this.
# Inlining improves execution speed but increases compilation time.
#
# context: user
# jit_inline_above_cost = 500000

# JIT provider to use. By default, uses the built-in LLVM provider.
#
# context: user
# jit_provider = 'llvmjit'

# Allow JIT compilation of expressions.
#
# context: user
# jit_expressions = on

# Allow JIT compilation of tuple deforming.
#
# context: user
# jit_tuple_deforming = on

# Register JIT-compiled functions with debugger.
# Useful for development and troubleshooting.
#
# context: user
# jit_debugging_support = off

# Register JIT-compiled functions with profiler.
# Useful for performance analysis.
#
# context: user
# jit_profiling_support = off

# Write out LLVM bitcode to facilitate JIT debugging.
# Useful for development and troubleshooting.
#
# context: user
# jit_dump_bitcode = off

#------------------------------------------------------------------------------
# LOGGING AND MONITORING
#------------------------------------------------------------------------------

# PostgreSQL's logging system is highly configurable and can provide
# valuable information for monitoring, troubleshooting, and performance tuning.

#------------------------------------------------------------------------------
# WHERE TO LOG
#------------------------------------------------------------------------------

# Sets the destination for server log output.
# Options (comma-separated list):
# - stderr: Log to stderr (console)
# - csvlog: Log in CSV format (requires logging_collector)
# - jsonlog: Log in JSON format (requires logging_collector)
# - syslog: Log to syslog
# - eventlog: Windows only - log to event log
#
# context: sighup
# log_destination = 'stderr'

# Start a subprocess to capture stderr output and/or csvlogs into log files.
# When off, logs only go to stderr. When on, logs are captured into files.
#
# Must be enabled to use csvlog, jsonlog, or to have log rotation.
#
# context: postmaster
# logging_collector = off

# Sets the directory for log files when logging_collector is enabled.
# Can be absolute or relative to PGDATA.
#
# context: sighup
# log_directory = 'log'

# Sets the file name pattern for log files when logging_collector is enabled.
# Uses strftime() pattern codes:
# %Y - year, %m - month, %d - day, %H - hour, %M - minute, %S - second
#
# Example: 'postgresql-%Y-%m-%d_%H%M%S.log'
#
# context: sighup
# log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'

# Sets the file permissions for log files when logging_collector is enabled.
# Default is 0600 (only owner can read/write).
#
# context: sighup
# log_file_mode = 0600

# Automatic log file rotation will occur after N minutes.
# 0 disables time-based rotation.
#
# context: sighup
# log_rotation_age = 1d

# Automatic log file rotation will occur after N kilobytes.
# 0 disables size-based rotation.
#
# context: sighup
# log_rotation_size = 10MB

# Truncate existing log files of same name during log rotation.
# When off, old logs are kept with a timestamp suffix. When on,
# old logs are overwritten.
#
# context: sighup
# log_truncate_on_rotation = off

#------------------------------------------------------------------------------
# SYSLOG SPECIFIC
#------------------------------------------------------------------------------

# When logging to syslog, these control the syslog facility and identifier.

# Sets the syslog "facility" to be used when syslog is enabled.
# Options: LOCAL0, LOCAL1, ..., LOCAL7
#
# context: sighup
# syslog_facility = 'LOCAL0'

# Sets the program name used to identify PostgreSQL messages in syslog.
#
# context: sighup
# syslog_ident = 'postgres'

# Add sequence number to syslog messages to avoid duplicate suppression.
#
# context: sighup
# syslog_sequence_numbers = on

# Split messages sent to syslog by lines and to fit into 1024 bytes.
# This is needed for some syslog implementations.
#
# context: sighup
# syslog_split_messages = on

#------------------------------------------------------------------------------
# PROCESS TITLE
#------------------------------------------------------------------------------

# Updates the process title to show the active SQL command.
# This is useful for monitoring active queries with tools like 'ps'.
# Can be disabled to reduce overhead if not needed.
#
# context: superuser
# update_process_title = on

# The application name used to identify PostgreSQL messages in the event log.
# Only relevant on Windows.
#
# context: postmaster
# event_source = 'PostgreSQL'

#------------------------------------------------------------------------------
# WHAT TO LOG
#------------------------------------------------------------------------------

# Controls information prefixed to each log line.
# Format codes:
# %a = application name
# %u = user name
# %d = database name
# %r = remote host and port
# %h = remote host
# %p = process ID
# %t = timestamp without milliseconds
# %m = timestamp with milliseconds
# %n = timestamp with milliseconds (as a Unix epoch)
# %i = command tag
# %e = SQL state
# %c = session ID
# %l = log line number for each session
# %s = session start time
# %v = virtual transaction ID
# %x = transaction ID (0 if none)
# %q = query ID (0 if none)
#
# Recommended format for machine parsing:
# '%m [%p] %q [%c] %u@%d '
#
# Recommended format for human reading:
# '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
#
# context: sighup
# log_line_prefix = '%m [%p] '

# Sets the time zone to use in log messages.
# Default is 'GMT', but you might want to set it to your local timezone
# for easier log analysis.
#
# context: sighup
# log_timezone = 'GMT'

# Log the host name in the connection logs.
# Disabled by default because it can cause a performance hit due to DNS lookups.
#
# context: sighup
# log_hostname = off

#------------------------------------------------------------------------------
# LOG LEVELS
#------------------------------------------------------------------------------

# Sets the message levels that are logged.
# Valid values in order of increasing detail:
# - debug5, debug4, debug3, debug2, debug1
# - info
# - notice
# - warning
# - error
# - log
# - fatal
# - panic (server errors only)
#
# context: superuser
# log_min_messages = warning

# Sets the message levels that are sent to the client.
# Valid values in order of increasing detail:
# - debug5, debug4, debug3, debug2, debug1
# - info
# - notice
# - warning
# - error
# - fatal
# - panic (server errors only)
#
# context: user
# client_min_messages = notice

# Causes all statements generating error at or above this level to be logged.
# Valid values: debug5, debug4, debug3, debug2, debug1, info, notice, warning,
# error, log, fatal, panic
#
# context: superuser
# log_min_error_statement = error

# Sets the verbosity of logged messages.
# Options:
# - terse: Just the error message
# - default: Error message, DETAIL, HINT, QUERY
# - verbose: All available information
#
# context: superuser
# log_error_verbosity = default

#------------------------------------------------------------------------------
# TIMING STATISTICS
#------------------------------------------------------------------------------

# Logs the duration of each completed SQL statement.
# Useful for finding slow queries, but can generate a lot of log traffic.
#
# context: superuser
# log_duration = off

# Sets the minimum execution time (in milliseconds) above which
# statements will be logged. -1 disables logging statement durations.
#
# A good value is often between 100-1000ms to catch slow queries
# without excessive logging.
#
# context: superuser
# log_min_duration_statement = -1

# Sets the minimum execution time above which a sample of statements will be logged.
# Sampling is determined by log_statement_sample_rate.
#
# context: superuser
# log_min_duration_sample = -1

# Fraction of statements exceeding log_min_duration_sample to be logged.
# 1.0 logs all such statements, 0.5 logs about half.
#
# context: superuser
# log_statement_sample_rate = 1.0

# Sets the fraction of transactions from which to log all statements.
# 0.1 logs statements from about 10% of transactions.
#
# context: superuser
# log_transaction_sample_rate = 0.0

#------------------------------------------------------------------------------
# DETAILED LOGGING OPTIONS
#------------------------------------------------------------------------------

# Sets the type of statements logged.
# Options:
# - none: Don't log statements
# - ddl: Log data definition statements (CREATE, ALTER, DROP)
# - mod: Log DDL plus data-modifying statements (INSERT, UPDATE, DELETE)
# - all: Log all statements
#
# context: superuser
# log_statement = 'none'

# Logs long lock waits. A lock wait longer than deadlock_timeout will be logged.
#
# context: superuser
# log_lock_waits = off

# Logs each successful connection.
#
# context: superuser-backend
# log_connections = off

# Logs end of a session, including duration.
#
# context: superuser-backend
# log_disconnections = off

# Logs each checkpoint. For each checkpoint, logs:
# - Time spent writing dirty buffers
# - Number of buffers written
# - Files written/sync'd
#
# context: sighup
# log_checkpoints = off

# Logs each replication command like IDENTIFY_SYSTEM, BASE_BACKUP, etc.
#
# context: superuser
# log_replication_commands = off

# Sets the minimum execution time (in milliseconds) above which
# autovacuum actions will be logged. -1 disables logging autovacuum actions.
#
# context: sighup
# log_autovacuum_min_duration = -1

# Logs standby recovery conflict waits. Useful for monitoring hot standby
# systems and troubleshooting replication conflicts.
#
# context: sighup
# log_recovery_conflict_waits = off

# Log the use of temporary files larger than this number of kilobytes.
# Useful for identifying operations that are using large amounts of temp space.
# A value of 0 logs all temp files, -1 disables logging.
#
# context: superuser
# log_temp_files = -1

# When logging statements, limit logged parameter values to first N bytes.
# This prevents large parameter values (like big texts or blobs) from
# overwhelming the logs. -1 means no limit.
#
# context: user
# log_parameter_max_length = -1

# When reporting an error, limit logged parameter values to first N bytes.
# This prevents large parameter values from overwhelming error logs.
# 0 means no limit.
#
# context: user
# log_parameter_max_length_on_error = 0

#------------------------------------------------------------------------------
# PERFORMANCE STATISTICS
#------------------------------------------------------------------------------

# Various options for logging detailed performance statistics.
# These should generally be disabled in production as they create significant
# overhead.

# Writes parser performance statistics to the server log.
#
# context: superuser
# log_parser_stats = off

# Writes planner performance statistics to the server log.
#
# context: superuser
# log_planner_stats = off

# Writes executor performance statistics to the server log.
#
# context: superuser
# log_executor_stats = off

# Writes cumulative performance statistics to the server log.
#
# context: superuser
# log_statement_stats = off

#------------------------------------------------------------------------------
# STATISTICS
#------------------------------------------------------------------------------

# PostgreSQL can collect and report on database activity for monitoring
# and performance analysis.

#------------------------------------------------------------------------------
# QUERY MONITORING
#------------------------------------------------------------------------------

# Collects information about executing commands.
# This powers tools like pg_stat_activity. Should generally be left on.
#
# context: superuser
# track_activities = on

# Sets the size reserved for pg_stat_activity.query, in bytes.
# Longer queries will be truncated. Default is usually sufficient.
#
# context: postmaster
# track_activity_query_size = 1kB

# Collects statistics on database activity.
# This powers various pg_stat_* views. Should generally be left on.
#
# context: superuser
# track_counts = on

# Collects function-level statistics on database activity.
# Options:
# - none: No stats
# - pl: Only track procedural language functions
# - all: Track all functions
#
# context: superuser
# track_functions = none

# Collects timing statistics for database I/O activity.
# This adds overhead but provides valuable performance data.
#
# context: superuser
# track_io_timing = off

# Collects timing statistics for WAL I/O activity.
# This adds overhead but provides valuable WAL performance data.
#
# context: superuser
# track_wal_io_timing = off

# Collects transaction commit time.
# This enables tracking of when transactions were committed.
#
# context: postmaster
# track_commit_timestamp = off

# Sets the directory where statistics temporary files are stored.
# Generally should be left at the default.
#
# context: sighup
# stats_temp_directory = 'pg_stat_tmp'

#------------------------------------------------------------------------------
# AUTOVACUUM
#------------------------------------------------------------------------------

# Autovacuum automatically runs VACUUM and ANALYZE commands to maintain
# database health and performance. Proper configuration is essential to
# prevent database bloat and maintain query performance.

# Starts the autovacuum subprocess. Should almost always be enabled.
# Disabling requires manual VACUUM and ANALYZE.
#
# context: sighup
# autovacuum = on

# Time to sleep between autovacuum runs.
# Shorter intervals mean more frequent cleanup but more overhead.
#
# context: sighup
# autovacuum_naptime = 1min

# Number of tuple inserts, updates, or deletes prior to vacuum as a fraction
# of reltuples (table rows). For example, 0.2 means vacuum when 20% of the
# table has been modified.
#
# Lower values trigger more frequent vacuums, reducing bloat but increasing overhead.
# Higher values reduce overhead but may allow more bloat to accumulate.
#
# context: sighup
# autovacuum_vacuum_scale_factor = 0.2

# Minimum number of tuple updates or deletes prior to vacuum.
# This sets a floor for when vacuuming occurs, regardless of table size.
# Useful for small tables, where scale_factor might never be reached.
#
# context: sighup
# autovacuum_vacuum_threshold = 50

# Number of tuple inserts prior to vacuum as a fraction of reltuples.
# This specifically tracks insert-only activity, which can create bloat
# in specific scenarios.
#
# context: sighup
# autovacuum_vacuum_insert_scale_factor = 0.2

# Minimum number of tuple inserts prior to vacuum.
# Set to -1 to disable insert vacuums.
#
# context: sighup
# autovacuum_vacuum_insert_threshold = 1000

# Number of tuple inserts, updates, or deletes prior to analyze as a fraction
# of reltuples. For example, 0.1 means analyze when 10% of the table
# has changed.
#
# Lower values mean more up-to-date statistics but more overhead.
# Higher values reduce overhead but may lead to suboptimal query plans.
#
# context: sighup
# autovacuum_analyze_scale_factor = 0.1

# Minimum number of tuple inserts, updates, or deletes prior to analyze.
# This sets a floor for when analyzing occurs, regardless of table size.
#
# context: sighup
# autovacuum_analyze_threshold = 50

# Age at which to autovacuum a table to prevent transaction ID wraparound.
# This is critical for database safety. Wraparound can cause severe data loss.
#
# context: postmaster
# autovacuum_freeze_max_age = 200000000

# Multixact age at which to autovacuum a table to prevent multixact wraparound.
# This is critical for database safety.
#
# context: postmaster
# autovacuum_multixact_freeze_max_age = 400000000

# Maximum number of simultaneously running autovacuum worker processes.
# More workers allow more tables to be processed simultaneously.
#
# Recommended settings:
# - Small systems: 2-3
# - Medium systems: 3-5
# - Large systems: 6-10, depending on hardware
#
# context: postmaster
# autovacuum_max_workers = 3

# Vacuum cost delay in milliseconds, for autovacuum.
# This slows down vacuum to reduce its impact on concurrent queries.
# A value of -1 uses the regular vacuum_cost_delay.
#
# context: sighup
# autovacuum_vacuum_cost_delay = 2ms

# Vacuum cost amount available before napping, for autovacuum.
# Higher values allow vacuum to do more work before pausing.
# A value of -1 uses the regular vacuum_cost_limit.
#
# context: sighup
# autovacuum_vacuum_cost_limit = -1

#------------------------------------------------------------------------------
# STATISTICS CONSISTENCY
#------------------------------------------------------------------------------

# Sets the consistency of accesses to statistics data.
# Options:
# - none: No consistency guarantee, fastest
# - cache: Use cached statistics if available (default)
# - snapshot: Use consistent snapshot of statistics
#
# context: user
# stats_fetch_consistency = cache


#------------------------------------------------------------------------------
# CLIENT CONNECTION DEFAULTS
#------------------------------------------------------------------------------

# These parameters control various default client settings.

#------------------------------------------------------------------------------
# STATEMENT BEHAVIOR
#------------------------------------------------------------------------------

# Sets the search path for schemas. Schemas are searched in the order listed.
# The default includes "$user" (a schema with the same name as the current user)
# and "public".
#
# context: user
# search_path = '"$user", public'

# Sets the default tablespace to create tables and indexes in.
# Empty string means use the database's default tablespace.
#
# context: user
# default_tablespace = ''

# Sets the default tablespace(s) to use for temporary tables and sort files.
# Can be a comma-separated list to distribute temporary objects across
# multiple tablespaces.
#
# context: user
# temp_tablespaces = ''

# Check function bodies during CREATE FUNCTION and CREATE PROCEDURE.
# This validates the function body syntax at creation time.
# Turn off only if you're restoring functions from a dump.
#
# context: user
# check_function_bodies = on

# Sets the default transaction isolation level.
# Options:
# - read uncommitted: Allows dirty reads (not recommended)
# - read committed: Prevents dirty reads but allows non-repeatable reads (default)
# - repeatable read: Prevents dirty and non-repeatable reads
# - serializable: Prevents all anomalies, but with performance impact
#
# context: user
# default_transaction_isolation = 'read committed'

# Sets the default read-only status of new transactions.
# When on, new transactions can't modify data.
#
# context: user
# default_transaction_read_only = off

# Sets the default deferrable status of new transactions.
# When on, constraints are checked at the end of the transaction.
# Only applies to serializable transactions.
#
# context: user
# default_transaction_deferrable = off

# Sets the current transaction's isolation level.
# Same options as default_transaction_isolation.
#
# context: user
# transaction_isolation = 'read committed'

# Sets the current transaction's read-only status.
# When on, the transaction can't modify data.
#
# context: user
# transaction_read_only = off

# Sets the current transaction's deferrable status.
# When on, constraints are checked at the end of the transaction.
# Only applies to serializable transactions.
#
# context: user
# transaction_deferrable = off

# Treats "expr=NULL" as "expr IS NULL".
# This is not SQL-standard behavior. Enable only for legacy code.
#
# context: user
# transform_null_equals = off

# Sets the maximum allowed duration of any statement.
# 0 means no timeout. This prevents runaway queries from consuming
# resources indefinitely.
#
# For production environments, consider setting between 30s-5min
# to prevent runaway queries.
#
# context: user
# statement_timeout = 0

# Sets the maximum allowed duration of any wait for a lock.
# 0 means no timeout. This prevents indefinite blocking on locks.
#
# For production environments, consider setting between 30s-5min
# to prevent deadlocks from causing extended outages.
#
# context: user
# lock_timeout = 0

# Sets the maximum allowed duration of any idling transaction.
# 0 means no timeout. This prevents idle transactions from holding
# resources indefinitely.
#
# context: user
# idle_in_transaction_session_timeout = 0

# Sets the maximum allowed idle time between queries, when not in a transaction.
# 0 means no timeout. This can automatically disconnect idle sessions.
#
# context: user
# idle_session_timeout = 0

# Vacuum cost delay in milliseconds. This throttles vacuum operations
# to reduce their impact on concurrent queries.
#
# 0 means no throttling (vacuum runs at full speed).
# Values between 10-50ms are common for busy production systems.
#
# context: user
# vacuum_cost_delay = 0ms

# Vacuum cost amount available before napping.
# Higher values allow vacuum to do more work before pausing.
#
# context: user
# vacuum_cost_limit = 200

# Vacuum cost for a page found in the buffer cache.
# This represents the cost of locking and processing a page already in memory.
#
# context: user
# vacuum_cost_page_hit = 1

# Vacuum cost for a page not found in the buffer cache.
# This represents the cost of reading a page from disk.
#
# context: user
# vacuum_cost_page_miss = 2

# Vacuum cost for a page dirtied by vacuum.
# This represents the cost of modifying a page.
#
# context: user
# vacuum_cost_page_dirty = 20

# Number of pages after which previously performed writes are flushed to disk
# during backend operations. This smooths I/O by spreading out writes.
#
# 0 disables incremental flushing. Higher values (e.g., 32, 64) can improve
# performance on systems with good I/O capacity.
#
# context: user
# backend_flush_after = 0

# Number of simultaneous requests that can be handled efficiently by the disk
# subsystem. Used for background writes and checkpoints.
#
# For RAID arrays, set approximately to the number of active drives.
# For SSDs, set much higher (e.g., 100-200).
# For single spinning disks, leave at 1 (default).
#
# context: user
# effective_io_concurrency = 1

# Maximum size of GIN index pending list.
# Larger values improve GIN index build performance but slow down searches
# until the index is cleaned with VACUUM.
#
# context: user
# gin_pending_list_limit = 4MB

# Maximum allowed result for exact search by GIN.
# 0 means no limit. This prevents slow GIN index searches.
#
# context: user
# gin_fuzzy_search_limit = 0

#------------------------------------------------------------------------------
# LOCALE AND FORMATTING
#------------------------------------------------------------------------------

# Sets the display format for date and time values.
# Common options: 'ISO', 'SQL', 'Postgres', 'German'
# The second parameter sets the order: 'DMY', 'MDY', 'YMD'
#
# context: user
# DateStyle = 'ISO, MDY'

# Sets the display format for interval values.
# Options: 'postgres', 'postgres_verbose', 'sql_standard', 'iso_8601'
#
# context: user
# IntervalStyle = 'postgres'

# Sets the time zone for displaying and interpreting time stamps.
# Default is 'GMT', but you might want to set it to your local timezone
# for ease of use.
#
# context: user
# TimeZone = 'GMT'

# Selects a file of time zone abbreviations.
# These define how timezone abbreviations like 'EST' are interpreted.
#
# context: user
# timezone_abbreviations = ''

# Sets the locale for formatting monetary amounts.
#
# context: user
# lc_monetary = 'C'

# Sets the locale for formatting numbers.
#
# context: user
# lc_numeric = 'C'

# Sets the locale for formatting date and time values.
#
# context: user
# lc_time = 'C'

# Sets the language in which messages are displayed.
#
# context: superuser
# lc_messages = 'C'

# Sets the number of digits displayed for floating-point values.
# Values can range from -15 to 3. Higher values show more digits.
#
# context: user
# extra_float_digits = 1

#------------------------------------------------------------------------------
# ICU LOCALE VALIDATION
#------------------------------------------------------------------------------

# Log level for reporting invalid ICU locale strings.
# Controls how aggressively PostgreSQL reports problems with ICU locale strings.
# Options from least to most severe: disabled, debug5-debug1, log, notice, warning, error
#
# context: user
# icu_validation_level = warning

#------------------------------------------------------------------------------
# OTHER CLIENT DEFAULTS
#------------------------------------------------------------------------------

# Sets how binary values are to be encoded in XML.
# Options: 'base64', 'hex'
#
# context: user
# xmlbinary = 'base64'

# Sets whether XML data in implicit parsing and serialization operations is
# to be considered as documents or content fragments.
# Options: 'content', 'document'
#
# context: user
# xmloption = 'content'

# Sets the client's character set encoding.
# Should generally match the server encoding for best performance.
#
# context: user
# client_encoding = 'SQL_ASCII'

# Default text search configuration.
# This defines the default text search parser and dictionary.
#
# context: user
# default_text_search_config = 'pg_catalog.simple'

# Sets the default compression method for compressible values.
# Options:
# - 'pglz': PostgreSQL's native compression (faster, less compression)
# - 'lz4': LZ4 compression (better compression ratio but more CPU)
#
# context: user
# default_toast_compression = 'pglz'

# Sets the application name to be reported in statistics and logs.
# Setting this helps identify the source of queries in monitoring tools.
#
# context: user
# application_name = ''

# Lists unprivileged shared libraries to preload into each backend.
# Use this to add functionality or hooks to regular user sessions.
#
# context: user
# local_preload_libraries = ''

# Sets the output format for bytea.
# Options: 'hex' (default), 'escape' (legacy format)
#
# context: user
# bytea_output = 'hex'

#------------------------------------------------------------------------------
# LOCK MANAGEMENT
#------------------------------------------------------------------------------

# Sets the time to wait on a lock before checking for deadlock.
# If a lock wait takes longer than this, the system will check if
# there's a deadlock. Lower values detect deadlocks faster but
# consume more resources.
#
# context: superuser
# deadlock_timeout = 1s

# Maximum number of locks per transaction. This limits the number of
# objects that can be locked by a single transaction.
#
# Increase if you see errors about "out of shared memory" or "too many
# locks" for complex queries or commands that affect many rows.
#
# context: postmaster
# max_locks_per_transaction = 64

# Maximum number of predicate locks per transaction. This limits the number
# of items that can be locked when using serializable isolation level.
#
# context: postmaster
# max_pred_locks_per_transaction = 64

# Maximum number of predicate-locked pages and tuples per relation.
# -2 means use a value based on max_pred_locks_per_transaction.
#
# context: sighup
# max_pred_locks_per_relation = -2

# Maximum number of predicate-locked tuples per page.
#
# context: sighup
# max_pred_locks_per_page = 2

#------------------------------------------------------------------------------
# VERSION AND PLATFORM COMPATIBILITY
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# PREVIOUS POSTGRESQL VERSIONS
#------------------------------------------------------------------------------

# Warns about constructs that changed meaning since PostgreSQL 9.4.
# Helps identify code that might behave differently in newer versions.
#
# context: user
# operator_precedence_warning = off

# Creates new tables with OIDs by default. This is a legacy feature
# and is generally not recommended in modern PostgreSQL.
#
# context: user
# default_with_oids = off

# Enables backward compatibility mode for privilege checks on large objects.
# In older PostgreSQL versions, permissions on large objects were less strict.
#
# context: superuser
# lo_compat_privileges = off

# Whether to defer a read-only serializable transaction until it can be
# executed with no possible serialization failures.
#
# context: user
# transaction_deferrable = off

#------------------------------------------------------------------------------
# CUSTOMIZED OPTIONS
#------------------------------------------------------------------------------

# When generating SQL fragments, quote all identifiers. This helps with
# portability between systems with different identifier naming rules.
#
# context: user
# quote_all_identifiers = off

# Enables backward compatibility mode for backslash escapes in ordinary
# string literals. When off, backslashes are treated as literal characters.
#
# Options:
# - 'on': Always allow backslash escapes
# - 'off': Never allow backslash escapes
# - 'safe_encoding': Allow only if client encoding doesn't allow ASCII chars in
#   multibyte characters (safest setting)
#
# context: user
# backslash_quote = safe_encoding

# Controls whether '...' strings treat backslashes literally.
# When on, backslashes are treated as literal characters, not escape characters.
# This is the SQL standard behavior.
#
# context: user
# standard_conforming_strings = on

# Warn about backslash escapes in ordinary string literals.
# This helps catch string literals that might behave differently
# when standard_conforming_strings is changed.
#
# context: user
# escape_string_warning = on

# Enables aggregation of multiple ROW/MULTISET values using the same transition state.
# This can improve performance of GROUP BY queries that aggregate many identical values.
#
# context: user
# synchronize_seqscans = on

# Use this table access method for new tables by default.
# Options:
# - 'heap': The standard storage method (default)
# - Can also be a custom table access method name
#
# context: user
# default_table_access_method = 'heap'

#------------------------------------------------------------------------------
# DEVELOPER OPTIONS
#------------------------------------------------------------------------------

# Track system indexes during operations that need full table access.
# Disabling this allows operations on system catalogs that would normally
# be rejected.
#
# DANGER: Setting to 'on' can corrupt your database. Only use
# when developing PostgreSQL itself or debugging system catalog issues.
#
# context: postmaster
# allow_system_table_mods = off

# Enables the planner to use constraints to optimize queries.
# Options:
# - 'off': Never use constraints
# - 'on': Always use constraints
# - 'partition': Only use constraints on partitioned tables (default)
#
# context: user
# constraint_exclusion = partition

# Disables reading from system indexes. Only use for recovering from
# damaged system indexes.
#
# context: backend
# ignore_system_indexes = off

# Continue processing past damaged page headers. This allows recovering
# data from corrupted tables, but can return wrong results.
#
# DANGER: Can produce incorrect query results. Only use for recovery.
#
# context: superuser
# zero_damaged_pages = off

# Whether to discard caches on system function calls. For developer testing.
#
# context: user
# debug_discard_caches = 0

# Indents parse and plan tree displays. Makes query plans more readable.
#
# context: user
# debug_pretty_print = on

# Logs each query's parse tree.
#
# context: user
# debug_print_parse = off

# Logs each query's rewritten parse tree.
#
# context: user
# debug_print_rewritten = off

# Logs each query's execution plan.
#
# context: user
# debug_print_plan = off

# Waits N seconds on connection startup before authentication.
# Useful for debugging connection issues.
#
# context: sighup
# pre_auth_delay = 0s

# Waits N seconds on connection startup after authentication.
# Useful for debugging server processes with a debugger.
#
# context: backend
# post_auth_delay = 0s

# Trace the processing of LISTEN and NOTIFY events.
#
# context: user
# trace_notify = off

# Emit information about resource usage in sorting.
# Useful for diagnosing sorting performance.
#
# context: user
# trace_sort = off

# Recovery-related debugging information log level.
# Options: 'debug', 'log', 'notice', 'warning', 'error' (and above)
#
# context: sighup
# trace_recovery_messages = log

# Sets the WAL resource managers for which WAL consistency checks are done.
# Comma-separated list, or 'all' to check all resource managers.
# Used to verify WAL integrity for debugging.
#
# context: superuser
# wal_consistency_checking = ''

#------------------------------------------------------------------------------
# ADDITIONAL DEVELOPER OPTIONS
#------------------------------------------------------------------------------

# Log backtrace for errors in these functions.
# Comma-separated list of function names for which a backtrace
# will be logged when they raise an error. Useful for debugging.
#
# context: superuser
# backtrace_functions = ''

# Use direct I/O for file access.
# Allows bypassing the operating system cache for certain file operations.
# Format is a comma-separated list of operations (e.g., 'basebackup').
#
# context: postmaster
# debug_io_direct = ''

# Whether to discard caches on system function calls. For developer testing.
# Higher values cause more aggressive cache discarding, useful for testing cache
# invalidation behaviors.
#
# context: user
# debug_discard_caches = 0

# Forces the planner's use parallel query nodes.
# Options:
# - off: Normal behavior (default)
# - on: Force consideration of parallel plans
# - regress: Special mode for regression tests
#
# context: user
# debug_parallel_query = off

# Logs details of pre-authentication connection handshake.
# Provides detailed logging of the protocol negotiation before authentication.
# Useful for troubleshooting connection issues.
#
# context: postmaster
# trace_connection_negotiation = off

# Send SIGABRT not SIGQUIT to child processes after backend crash.
# Changes the signal sent to child processes for better debugging.
#
# context: sighup
# send_abort_for_crash = off

# Send SIGABRT not SIGKILL to stuck child processes.
# Changes the signal sent to hung processes to allow core dumps for debugging.
#
# context: sighup
# send_abort_for_kill = off

# Log interval for long-running startup operations, in milliseconds.
# Controls how often progress updates are logged during potentially slow
# startup operations like crash recovery.
# 0 turns this feature off.
#
# context: sighup
# log_startup_progress_interval = 10000ms


#------------------------------------------------------------------------------
# ERROR HANDLING
#------------------------------------------------------------------------------

# Terminate session on any error.
# When on, any error will abort the current session.
#
# context: user
# exit_on_error = off

# Reinitialize server after backend crash.
# When on, the postmaster will restart after a backend crash.
#
# context: sighup
# restart_after_crash = on

# Whether to continue running after a failure to sync data files.
# When off, the server will stop if it can't write data files,
# forcing manual recovery.
#
# DANGER: Setting to 'on' can lead to data corruption if there are
# persistent I/O problems. Only use in emergency situations.
#
# context: postmaster
# data_sync_retry = off

# Continues processing past checksum failures.
# When on, the server will continue processing pages with invalid checksums.
#
# DANGER: Can lead to crashed servers, corrupt data, and wrong query results.
# Only use for recovery attempts.
#
# context: superuser
# ignore_checksum_failure = off

# Continues recovery after invalid pages failure.
# When on, the server will skip invalid pages during recovery rather than
# failing outright.
#
# DANGER: Can lead to data inconsistencies. Only use for recovery attempts.
#
# context: superuser
# ignore_invalid_pages = off

# Remove temporary files after backend crash. Generally should be left on
# to prevent accumulation of temporary files.
#
# context: sighup
# remove_temp_files_after_crash = on

#------------------------------------------------------------------------------
# MISCELLANEOUS
#------------------------------------------------------------------------------

# Sets the name of the cluster, which is included in the process title.
# This helps identify PostgreSQL instances when you have multiple clusters.
#
# context: postmaster
# cluster_name = ''

# Maximum number of concurrent worker processes.
# This sets an upper bound on background workers used for various purposes.
#
# Recommended value based on CPU cores:
# - Small systems (1-2 cores): 8
# - Medium systems (4-8 cores): 8-16
# - Large systems (16+ cores): 16-32
#
# context: postmaster
# max_worker_processes = 8

# Sets whether a snapshot is too old to read pages changed after the snapshot
# was taken. This is in minutes; -1 disables the feature.
#
# This helps reclaim space by allowing removal of dead row versions.
# However, it can cause transactions to fail with snapshot too old errors.
#
# For OLTP: Consider 60-120 minutes
# For data warehouses: Consider 240+ minutes or -1
#
# context: postmaster
# old_snapshot_threshold = -1

# Lists shared libraries to preload into server.
# Useful for extensions that need to register custom hooks.
#
# Examples:
# shared_preload_libraries = 'pg_stat_statements'
# shared_preload_libraries = 'pg_stat_statements,auto_explain'
#
# context: postmaster
# shared_preload_libraries = ''

# Sets the path for dynamically loadable modules.
# Default is $libdir which refers to PostgreSQL's module installation directory.
#
# context: superuser
# dynamic_library_path = '$libdir'

# Lists shared libraries to preload into each backend.
# Similar to shared_preload_libraries but loaded per backend.
#
# context: superuser
# session_preload_libraries = ''

# Sets the session's behavior for triggers and rewrite rules.
# Options:
# - 'origin': Normal mode (default)
# - 'replica': Suppresses trigger and rewrite operation
# - 'local': Allow only suppressed operations to be performed
#
# Used primarily for logical replication conflict handling.
#
# context: superuser
# session_replication_role = 'origin'

# Allows row security policies to be enforced. When enabled, SELECT, INSERT,
# UPDATE, and DELETE commands may be restricted by row security policies.
#
# context: user
# row_security = on

# Minimum age at which VACUUM should freeze a table row.
# Freezing row versions marks them as "visible to all transactions"
# allowing VACUUM to remove dead rows.
#
# context: user
# vacuum_freeze_min_age = 50000000

# Age at which VACUUM should scan whole table to freeze tuples.
# When a table reaches this age, VACUUM will perform a more aggressive
# freeze operation.
#
# context: user
# vacuum_freeze_table_age = 150000000

# Minimum age at which VACUUM should freeze a MultiXactId in a table row.
# Similar to vacuum_freeze_min_age but for multiXactIds.
#
# context: user
# vacuum_multixact_freeze_min_age = 5000000

# Multixact age at which VACUUM should scan whole table to freeze tuples.
# Similar to vacuum_freeze_table_age but for multiXactIds.
#
# context: user
# vacuum_multixact_freeze_table_age = 150000000

# Age at which VACUUM should trigger failsafe to avoid a transaction
# ID wraparound outage. When this age is reached, an aggressive vacuum
# is triggered that can impact system performance.
#
# context: user
# vacuum_failsafe_age = 1600000000

# Multixact age at which VACUUM should trigger failsafe to avoid a
# multixact wraparound outage. Similar to vacuum_failsafe_age but
# for multixacts.
#
# context: user
# vacuum_multixact_failsafe_age = 1600000000

# Number of transactions by which VACUUM and HOT cleanup should be
# deferred, if any. This helps prevent vacuum operations from
# conflicting with read operations on standby servers.
#
# context: sighup
# vacuum_defer_cleanup_age = 0


#------------------------------------------------------------------------------
# BONJOUR SETTINGS
#------------------------------------------------------------------------------

# Whether to advertise server availability via Bonjour.
# Useful for automatic server discovery on local networks.
#
# context: postmaster
# bonjour = off

# Sets the Bonjour service name.
# This is what the server will identify as on the Bonjour network.
# Empty string selects the computer name.
#
# context: postmaster
# bonjour_name = ''

#------------------------------------------------------------------------------
# GSSAPI AND KERBEROS DELEGATION
#------------------------------------------------------------------------------

# Controls whether GSSAPI delegation should be accepted from client.
# When enabled, allows forwarding of client credentials to other services.
# Only enable if your application needs to access other Kerberos-secured services.
#
# context: sighup
# gss_accept_delegation = off

#------------------------------------------------------------------------------
# RESERVED CONNECTIONS
#------------------------------------------------------------------------------

# Sets the number of connection slots reserved for roles with privileges of 
# pg_use_reserved_connections. This ensures that certain applications or
# monitoring tools can connect even when the server reaches max_connections.
#
# context: postmaster
# reserved_connections = 0

#------------------------------------------------------------------------------
# BACKGROUND WRITER
#------------------------------------------------------------------------------
# The background writer process periodically writes dirty buffers to disk.
# This helps reduce the number of buffers that need to be written during
# checkpoints, which can help spread I/O load more evenly.

#------------------------------------------------------------------------------
# BACKGROUND WRITER SETTINGS
#------------------------------------------------------------------------------

# Background writer sleep time between rounds, in milliseconds.
# Controls how frequently the background writer process runs to flush dirty buffers.
#
# context: sighup
# bgwriter_delay = 200ms

# Number of pages after which previously performed writes are flushed to disk
# during background writer operations. This helps smooth I/O by spreading out writes.
#
# context: sighup
# bgwriter_flush_after = 64MB

# Background writer maximum number of LRU pages to flush per round.
# Controls how many dirty buffers the background writer can write in each round.
#
# context: sighup
# bgwriter_lru_maxpages = 100

# Multiple of the average buffer usage to free per round.
# Higher values make the background writer more aggressive in cleaning buffers.
#
# context: sighup
# bgwriter_lru_multiplier = 2


#------------------------------------------------------------------------------
# EVENT TRIGGERS
#------------------------------------------------------------------------------

# Enables event triggers.
# When enabled, event triggers will fire for all applicable statements.
# Event triggers are fired for database events like DDL commands.
# Disabling this can be useful for some maintenance operations.
#
# context: superuser
# event_triggers = on

#------------------------------------------------------------------------------
# TRANSACTION MANAGEMENT
#------------------------------------------------------------------------------

# Sets the maximum number of concurrent transactions.
# This is a hard limit on the number of transactions that can be in progress at any one time.

#------------------------------------------------------------------------------
# TRANSACTION TIMEOUT
#------------------------------------------------------------------------------

# Sets the maximum allowed duration of any transaction within a session
# (not a prepared transaction), in milliseconds. A value of 0 turns off the timeout.
# This can prevent long-running transactions from holding resources indefinitely.
#
# context: user
# transaction_timeout = 0ms

#------------------------------------------------------------------------------
# ADMINISTRATIVE ACCESS
#------------------------------------------------------------------------------

# Allows running the ALTER SYSTEM command.
# When enabled, allows privileged users to modify the server configuration
# through SQL commands. Can be set to off for environments where global
# configuration changes should be made using a different method.
#
# context: sighup
# allow_alter_system = on

#------------------------------------------------------------------------------
# TESTING OPTIONS
#------------------------------------------------------------------------------

# Allows tablespaces directly inside pg_tblspc, for testing.
# This option is only useful for testing and should not be enabled
# in production environments.
#
# context: superuser
# allow_in_place_tablespaces = off


#------------------------------------------------------------------------------
# EXTENSION MANAGEMENT
#------------------------------------------------------------------------------

# Path to prepend for extension loading.
# This directory is prepended to paths when loading extensions (control and SQL files),
# and to the '$libdir' directive when loading modules that back functions.
# Useful for testing extensions that have not been installed to their proper locations.
#
# context: superuser
# extension_destdir = ''



# End of postgresql.conf

